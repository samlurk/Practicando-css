/**<<<<<<SINTAXIS DE CSS>>>>>>

Selector: El elemento al que vamos aplicar estilos
Propiedad: Lo que vamos a cambiar
Valor: el nuevo valor que le vamos a dar la propiedad
Propiedad: valor -> Se le denomina declaracion
Al conjunto de selector+declaracion(es) se le denomina regla

Regla:
selector{ 
    propiedad:valor; declaracion
    propiedad2: valor; declaracion2
}


/**<<<<<<TIPOS DE SELECTORES>>>>>>*

~~~Selectores Simples
        Selectores elementales
            Selector Universal -> *
            Selector de tipo o etiquieta -> Nombre de la etiqueta
        Selectores de atributo
            id -> id del elemento
            clase -> clase del elemento
            otros atributos.
                [atributo]
                [atributo="valor"]
                [atributo^="valor"] Busca coincidencia al principio
                [atributo*="valor"] Busca coincidencia desde donde sea
                [atributo$="valor"] Seleccionar el valor si termina por esa palabra
                [atributo|="valor"] Incluye en y en-, ideal para lang
~~~Selectores Compuestos
        Selectores agrupados -> Se agrupan los selectores separados por comas y se escribeel estilo una sola vez
        Selectores Combinadores
            Selector descendiente -> Selector mayor Selector menor
            Selector de Hijos Selector -> Selector padre > Selector Hijos directos
            Selector de hermano(s) siguiente(s) 
                Selector para Hermanos siguientes -> Selector Hermano ~ Hermanos Siguientes (descendente html)
                Selector para Hermano siguiente en descendencia -> Hermano + hermano siguiente (descendente html)
        Pseudoclases - Pseudoelementos



/**<<UNIVERSAL>> Specify(0,0,0)

*{
    color: rgb(24, 89, 14); 
}

/**<<DE TIPO>> Specify(0,0,1)
h2{ 
    color: red;
}

/**<<DE CLASE>> Specify(0,1,0)
.title-h2{ 
    color:chocolate;
}
/**<<POR ATRIBUTO>> Specify(0,1,0)
[myAtributo]{
    color:darkred;
}

[myAtributo^="title"]{ Specify(0,1,0)
    color: red;
}

/**<<POR ID>> Specify(1,0,0)
#title-h2{
    color: blue;
}

/**<<POR DESCENDIENTE>>

div h2{ /*Specify(0,0,2)
    color: darkred;
}
.descendiente .title2-h2{ /*Specify(0,2,0)
    color: chocolate;
}
.descendiente [myAtributo2]{ /*Specify(0,2,0)
    color: red;
}
#title-h2 #title2-h2{ /*Specify(0,2,0)
    color:green;
}
/**PSEUDO-CLASES

.descendiente .title2-h2:hover{  /*Specify(0,3,0)
    color: red;
}

/**<<SELECTOR DE HIJOS>>
.descendiente > .title2-h2{ Specify(0,2,0)

}


/**<<<<<<ESPECIFIDAD>>>>>>

/**<<PSEUDO-ELEMENTOS>>

/**<<NIVEL DE JERARQUIA>>

!important 

Estilos en linea

Identificadores

Clases

Pseudo-clases

Atributos

Elementos

pseudo-elementos

    **El caculo de especifidad se realiza con la siguiente formula:
        Etiquetas y pseudo elementos 001
        Clases, atributos y pseudoclases 010
        Ids 100
        Estilos en linea 1000
        !important 10000
    Cascada -> Funciona siempre que la especifidad sobre el elemento sea la misma
    Herencia -> Capacidad que tienen algunos elementos de heredar algunas propiedades de sus elementos contenedores (padres, abuelos, etc)
*{
    color: blue !important;
}

h2{ /*Specify (0,0,1) important
    color: red !important;
}

#title2-h2{ /*Specify (1,0,0) important
    color:violet !important;
}

#title-h2 #title2-h2{ /*Specify (2,0,0) important
    color:green !important;
}

.title2-h2 + [myAtributo2="title-h2"] { /* Specify(0,2,0) Es el hermano siguiente en descendencia
    background-color: lightgreen;
}

.title2-h2 ~ [myAtributo2], .title2-h2 ~ #title2-h2{ /*Specify (0,2,0), Specify (1,1,0)
    background-color: lightskyblue;
}

body > .title-h2{ /*Specify (0,1,1)
    background-color:lightslategray;
}
/*<<A FONDO>>


h2 {
    color: blue;
}
h2.h2-title{ /*Specify (0,1,1)
    color: green;
}
.contenido h2.h2-title{ /*Specify (0,2,1)
    color: darkred;
}
h2#h2-title{/*Specify (1,0,1)
    color: brown;
}
h2.h2-title#h2-title{/*Specify (1,1,1)
    color: blueviolet;
}

div h2.h2-title#h2-title{ /*Specify 112 
    color: #000;
}
div.sub-contenido#sub-contenido h2{ /*Specify (1,1,1)
    color:chartreuse;
}
div.sub-contenido#sub-contenido  > h2.h2-title#h2-title:hover{ /*Specify (2,3,2)
    color:red;
}

h2.h2-title#h2-title + h2.h2-title#h2-title:hover{/*Specify ()
    color:blue;
}
div.sub-contenido#sub-contenido  h2.h2-title#h2-title:last-of-type:hover::first-letter{
    color:violet;
}

/*TENER UN CSS SIN PICOS, LO MAS LINEAL POSIBLE

/**<<<<<<HERENCIA>>>>>>*

~~~ Todos los temas entorno a fuentes y colores, se heredan.

~~~ Los enlaces no heredan propiedades de su padre.

.text{
    color: red;
}
a:link{
    
    text-decoration: none;
    color: inherit; /*La propiedad: inherit es para decir que queremos forzar la herencia, porque, en estos tipos de casos la propiedad no se hereda.
                    /*La propiedad initial es para decir que queremos que vuelvan a su estado inicial, todo aquello que estes heredando, ignoralo
}

li:not(.no-color){
    color: blue;
}

/**<<<<<<ESTILOS COMPUTADOS>>>>>>

/*body{
    color: rgba(255, 255, 255, 0.679);
    background-color: #333;
}

/*#title2-h2{
    color: red;
}
#title2-h2{
    color: lightskyblue;
}
/*user agent stylesheet | son estilos del navegador q trae por defecto

~~ Cuando se tenga un problema revisar el DevTools de Google, estilos y computados


/**<<<<<<BOX MODEL Y MARGIN >>>>>>
.title{
    width: 200px;
    margin-right: auto;
    margin-left: auto; /*! No se coloca a la derecha porque ocupa el ancho completo
    background-color: blue;
}
.block{
    background-color: purple;
    width: 200px;
    height: 200px;
    /*margin:  100px 50px 25px; 
    /*margin-left: auto;  /** Al darle el margen left y right calcula los 2 lados (centra la caja, no el texto)
    /*margin-right: auto;
}

/**Con bloques margin-right: auto; el elemento va a la izquierda e inverso a margin-left: auto;
 Para que esto funcione debe tener un ancho declarado y ser un elemento bloque


.inline{ /*Los elementos inline el tamaño no determina su contenido
    background-color: lightcoral;
    color: inherit;
    /*width: 200px; /*! no agarra
    /*height: 200px; /*! no agarra
    /*margin-top: 100px; /* !No agarra margen vertical
    /*margin-left: 200px; /*Agarra margen horizontal
}

/*
    Es la propiedad que nos permite generar espacio entre elementos 
    Es un shorthand que controla los 4 lados que dar margenes.
    margin-top 
    margin-right
    margin-bottom
    margin-left  

    Admite hasta 4 valores que van en el orden de las agujas del reloj
    4 valores -> margin: top right bottom left;
    3 valores -> margin: top left/right bottom;
    2 valores -> margin: top/bottom/ left/right;
    1 valor -> margin: top/right/bottom/left


/**<<<<<<<<<<METODOLOGIA BEM Y ORDEN DE ESTILOS EN CSS>>>>>>>>>>>>
.btn{
    width: 500px;
    margin: 30px auto 0px;
}

.btn__link{
    padding: 0.5em 1.1em;
    font-family: sans-serif;
    font-size: 0.95rem;
    text-decoration: none;
    color: white;
    background-color: #305BDF;
    border-radius: 1em;
}
.btn__link--primary:hover{
    background-color: #466DE2;
}
.btn__link--primary:active{
    background-color: #2251DD;
}
.btn__link--secondary{
    color: #4169E1;
    background-color: transparent;
    border: 2px solid #305BDF;
}
.btn__link--secondary:hover{
    color: #193CA3;
}
.btn__link--secondary:active{
    background-color: rgba(48,91,223, 0.15);
}
/*! ***********************MALAS PRACTICAS*****************************

/*! No utilizar margin 0 y padding 0 en caso de que se tenga un diseño y se requiera hacer todo

.block{
    margin-top:100px;
    /*margin: 0pxauto; /*!No utilizar esto para centrar
    margin-left: auto;
    margin-right: auto;
}

.header{
    background-color: red; /**Por defecto todos los navegadores ponen 8px de margin al body, resetearlas siempre (el normalize lo hace)
    height: 50px; /**No poner padding 0 en el body si no tiene, asegurarse de lo que se escribe tenga sentido, y escribirlo sabiendo por que lo estas escribiendo
    /**: No escribir codigo por que lo hemos visto en nosedonde
}

/**<<<<<<<<<<PADDING >>>>>>>>>>>>
/*Admite hasta los 4 valores que van en el orden de las agujas del reloj

.block{
    padding: 100px 10px 100px;
}
/**<<<<<<<<<<BORDER>>>>>>>>>>>>

/*Es un shorthand y agrupa 3 propiedades
    border-width
        border-top-width
        border-right-width
        border-bottom-width
        border-left-width
    border-style
        border-top-style
        border-right-style
        border-bottom-style
        border-left-style
            Listado de valores de style:
                none
                hidden
                dotted
                dashed
                doubled *divide espacios (divide el borde entre 2)*
                solid
                groove *hace sombra 3D*
                ridge *hace alreves lo que hace groove*
                inset (tenemos 2 bordes al diagonal de la caja)
                outset (invertir los 2 bordes de inset)
    border-color
        border-top-color
        border-right-color
        border-bottom-color
        border-left-color

.block{
    border: 20px solid slateblue;
    border-top-width: 10px;
    border-bottom-style:dotted;
    border-left-color: red;
}
/**<<<<<<<<<<BOX SIZING>>>>>>>>>>>>

/*Es la propiedad que nos permite controlar el calculo que hace el navegador a la hora de modificar las propiedades content, padding y border
    /*Los 2 valores que podemos darle son
        content-box -> Valor por defecto
        border-box -> Calculo de tamaño del elemento
        incluyento el padding y el border

.block{
    padding: 20px;
}

/**<<<<<<<<<<BORDER RADIUS CIRCULAR>>>>>>>>>>>>

Permite redondear vertices de forma independiente. Es un shorthand.

border-top-left-radius 
border-top-right-radius
border-top-bottom-right-radius
border-top-bottom-left-radius

.block{
    width: 200px;
    height: 200px;
    background-color: #ff0800;
    margin: 0px auto 0px;
    /*border-radius: 50px;
    /*ORDEN
    /*border-top-left-radius: 25px;
    border-top-right-radius: 50px;
    border-bottom-right-radius: 25px;
    border-bottom-left-radius: 75px;
    
    border-radius: esq. sup. izq. + esq. inf. der. | esq. sup. der. + esq. inf. izq. *2*
    border-radius:  esq. sup. izq. | esq. sup. der. (esq. inf. izq. toma el valor q tiene al frente )|  esq. inf. der. *3*
    border-radius:  esq. sup. izq. | esq. sup. der. |  esq. inf. der. | esq. inf. izq. *4*
    
}

/**<<<<<<<<<<BORDER RADIUS ELIPSES>>>>>>>>>>>

.block{
    border-top-left-radius: 50px 100px; /*ELIPSE EN UN SOLO LADO
    border-radius: 50px / 100px; /*50px en el eje X y 50 en el eje Y
}
.palo{
    width: 20px;
    height: 30px;
    margin: 300px auto 0px;
    background-color: #000;
    border-top-right-radius: 25px;
    border-bottom-left-radius: 30px;
}

/**<<<<<<<<<<OVERFLOW>>>>>>>>>>>

/*Es la propiedad de que controla que debe hacer la caja cuando su contenido se desborda del contenedor
    Es un shorthand que engloba overflow-x y overflow-y
    Tiene 4 posibles valores:
    visible -> Es el valor por defecto.
    hidden -> El contenido que se desborde no se verá. Si aplicamos esta propiedad en un solo eje, el otro se pondrá automáticamente en el valor scroll
    scroll -> Apareceran barras de scroll en el eje asignado (x, y o ambos)
    auto -> Apareceran barras de scroll en el caso de que hicieran falta 

/*.block{
    width: 300px;
    height: 300px;
    border-radius: 50px;
    margin: 0px auto 0px;
    background-color: #ff0800;

    overflow: hidden;
}
.text{
    /*width: 350px;
    margin: 0px;
}
.box-1, .box-2{
    padding: 30px 20px 10px;
    background-color: blue;
}

/**<<<<<<<<<<COLAPSADO DE MARGENES>>>>>>>>>>>
/*
LOS MARGENES VERTICALES COLAPSAN
Si la caja anterior tiene bottom de 20px y la siguiente tiene top de 30px, 20px se solapan y solamente se estiran 10px
Es decir...
LOS MARGENES SE SOLAPAN

SE SOLUCIONA DANDOLE MARGIN BOTTOM A TODOS LOS ELEMENTOS

body{
    background-color:midnightblue;
    
}
.header{
    background-color: lightcoral;
    height: 100px;
    margin-bottom: 20px;
    /**3 FORMAS DE SOLUCIONAR EL COLAPSADO DE IMAGENES ENTRE PADRES E HIJOS
    /*overflow: hidden;
    /*padding-top: 0.1px;
    border-top: 0.1px solid lightcoral;
}
.box-1,
.box-2{
    margin-left: auto;
    margin-right: auto;
    background-color: lightcyan;
    width: 300px;
    height: 300px;
}
/**No juntar margin bottom y margin tops porque daran muchos dolores de cabeza [Solo pasa en margenes verticales]
/*! Esto no lo hariamos 
.box-2{ 
    margin-top: 20px;
} 
.box-1{
    margin-bottom: 30px;
}
.title{
    margin: 0px; /*Se soluciona porque el h1 tiene margenes y los reseteamos
    margin-top: 30px;
}
h1{
    color:aliceblue;
}
/**<<<<<<<<<<DISPLAY>>>>>>>>>>>
Sirve para cambiar el contexto de los elementos dentro del navegador

Admite varios valores
    none -> Hace que el elemento no se muestre, pero sigue cargandose 
    block -> Hace que el elemento sea de bloque
    inline -> Hace que el elemento sea de linea
    inline-block -> Hace que el elemento sea de linea pero admite medidas y margenes verticales
    
body{
    background-color: rgba(0,0,0,.9);
}
.text{
    background-color: lightcoral;
}
.link{
    display:inline-block; /*El elemento crece pero sigue siendo de linea
    margin-top: 20px;
    background-color: #fff;
}

/**<<<<<<<<<<OUTLINE>>>>>>>>>>>
Es la propiedad que nos permite dibujar un borde por fuera del modelo de la caja.
Es un shorthand que engloba 
    outline-width
    outline-style
    outline-color

Tiene las mismas propiedades y sintaxis que border,
pero con algunas diferencias.
    No ocupa sitio, ya que no forma parte del box-model
    No se puede redondear 
    No se pueden controlar los lados de forma independiente

    Tambien cuenta con la propiedad outline-offset, que permite
    aumentar o disminuir la distancia del outline respecto a la caja que pertenece.
body{
    background-color: rgba(0,0,0,.9);
    color: white;
}

.border,
.outline{
    background-color: #666;
    width: 100px;
    padding: 10px 20px;
    margin: 50px 100px;
}
.border{
    border: 20px solid lightcoral;
}
.outline{
    outline: 3px solid lightcoral;
    /*border: 50px solid lightgreen;
    outline-offset: -13px; /**Podemos ponerlo dentro de la caja, cosa que con border no podemos hacer
    border: 3px solid lightgreen;
}
/*El borde tiene el problema que va estar modificando la caja, aumenta el tamanio de la caja y empuja los elementos
Aunque tengamos el box-sizing: border box
la caja no tiene medidas
Por lo tanto mide 50px de borde mas lo que tiene de contenido


/**<<<<<<<<<<TEXT ALIGN>>>>>>>>>>>
    Text-align es la propiedad que nos permite alinear horizontalmente el contenido de un elemento de bloque siempre que
    el contenido NO TENGA ANCHO DECLARADO
    text-align: left; -> Alinea Contenido a la der.
    text align: right; -> Alinea el contenido a la derecha
    text-align: center; -> Alinea el contenido al centro
    text-align: justify; -> Alinea el contenido de forma justificada. No es recomendable usarlo.

body{
    background-color: #333;
    color: white;
}
.box{
    background-color: #666;
    width: 100px;
    padding: 10px 0px;
    margin: 20px auto;
    border: 2px solid lightcoral;
    text-align: center; /**Si se puede porque el contenido no tiene ancho declarado
}
.text{
    text-align: left; /*El contenido suele estar alineado a la izquierda
    text-align: right;
    text-align: center;
    text-align: justify; /*No recomendable usar, quedan espacios feos entre palabras
}
.link{
    display: block; /*! No centra con inline e inline-block
    width: 200px; /**No centrara  con text align porque el contenido tiene un ancho declarado
    margin: 0px auto 20px;
    background-color: #666;
    color: white;
    text-align: center; /*! No se puede
    /*Text-align centra a los contenidos de los elementos de bloque
}
/*.img{
    display: block; /**EL contenido es la propia imagen y la imagen esta ocupado todo el tamaño de la caja 
    margin: 0px auto 0px;
    /*text-align: center; /*! No pasa nada
    /**Las imagenes por defecto son display inline block
}

/*Centrar la imagen desde un contenedor
.img-container{ /**La imagen centra, siempre y cuando no tenga un display block
    text-align: center;
}
/*.img{
    display: block; /*! No centra con img-container porque la imagen esta ocupando todo lo que puede*
}
/**TENER EN CUENTA SI LO QUE CENTRAMOS ES EL CONTENIDO DE UNA CAJA O LA CAJA EN SI


/**<<<<<<<<<<BOX SHADOW>>>>>>>>>>>
    La sintaxis de box-shadow se puede escribir de distintas formas segun lo que queramos conseguir.
    Los valores que le podemos poner son:
    offset-x -> Desplazamiento en x (obligatorio)
    offset-y -> Desplazamiento en y (obligatorio)
    blur-radius -> Desenfoque de la sombra
    spread-radius -> Expansion de la sombra
    color -> El color de la sombra, si no lo especificamos heredará del elemento al que pertenece
    inset -> Determina si la sombra será interior o exterior

.box{
    background-color: darkcyan;
    width: 200px;
    padding: 50px;
    text-align: center;
    margin: 50px auto 0px;
    border-radius: 30px;
    /*box-shadow: inset -5px -5px 10px 0px #111;
    /**El box shadow toma como herencia el color de la caja, si la letra esta en negra pues estara igual la sombra
    box-shadow: inset -5px -5px 10px red, 5px 5px 10px blue; /**Se pueden crear multiples sombras. Box shadow funciona como outline porque no mueve las cajas
}
/**<<<<<<<<<<POSITION>>>>>>>>>>>
    Position nos permite posicionar los elementos. Conceptos en tener en cuenta antes de entender position
    
    Flujo de renderizado -> Por norma general los elementos se dibujan de izquierda a derecha y de arriba abajo.
    El punto 0,0 de los elementos, por norma general, es la esquina superior izquierda.

    Espacio reservado -> Es el espacio que tiene un elemento asignado en el navegador.

    Elemento posicionado -> Esto significa que el elemento tiene la propiedad position con un valor de "static",
    que es el valor que tiene esta propiedad por defecto.

    Stackin context -> Contexto de apilamiento. Es el orden en el que se apilaran las cajas que se superponen,
    dentro del mismo contenedor.
    
    Al posicionar un elemento se habilitan 5 propiedades que podemos utilizar para mover
    los elementos en los 3 ejes.

    top -> El elemento se moverá desde la parte superior la distancia que le hayamos indicado.

    right -> El elemento se moverá desde la parte derecha la distancia que le hayamos indicado.

    bottom -> El elemento se moverá desde la parte inferior la distancia que le hayamos indicado

    left -> El elemento se mover[a desde la parte izquierda la distancia que le hayamos indicado.

    z-index -> Nos permite mover el elemento en el contexto de apilamiento (eje z)

    NOTA: Si a un elemento le declaramos la propiedad top y/o Left, las propiedades bottom y/o right no funcionarán

    Los posibles valores que le podemos dar a position son.
    Static -> Es el valor que tiene por defecto un elemento, con este valor el elemento 
    NO ESTÁ POSICIONADO y por lo cual no podemos moverlo 

    Elemento posicionados: 

    Relative -> El elemento mantendrá su posición y medidas en el flujo de renderizado y mantendrá su espacio reservado.
    Si lo movemos lo hará usando su posición en el html como punto de referencia.

    Absolute -> El elemento pederá sus medidas y su espacio reservado. Si lo movemos usará el elemento padre posicionado
    como referencia. Si no tiene ninguno, usará el elemento html de referencia.

    Fixed: -> El elemento perderá sus medidas y su espacio reservado.
    Si lo movemos usará el elemento html de referencia, y además se quedará fijo en esa posición aunque hagamos scroll.

    Sticky -> Es una mezcla de position relative y fixed.
    Con este tipo de posicionamiento los valores top, left, bottom y right no sirven para mover el elemento,
    si  no para indicarle en que punto pasará a tener un comportamiento de posicionamiento fixed, hasta llegar a ese punto
    se comportará como si tuviera relative.


    **<<<<<<<<<<POSITION RELATIVE>>>>>>>>>>>


body{
    background-color: #333;
}
.box {
    width: 100px;
    height: 100px;
}
.box-1{
    background-color: lightcoral;
    position: relative;
    top: 50px;
    left: 50px; /**Acepta valores negativos
    /*right: 25px; /*! No funciona porque ya tiene left
    /*bottom: 25px; /*! No funciona porque ya tiene top
    border-radius: 50px; /**El punto de referencia siempre es el mismo

} /**No se mueven al mismo sitio box-1 y box-2 porque se mueve desde la posicion inicial que les corresponde del html
.box-2{
    position: relative;
    right: 50px;    
    background-color: lightgreen;
} /**En posicion relative se le puede obligar a los elementos usar un mismo espacio

    **<<<<<<<<<<POSITION ABSOLUTE>>>>>>>>>>>

body{
    background-color: #333;
}
.box{
    width: 100px;
    height: 100px;

    text-align: center;
}
.container{
    position: relative; /**Si se cambia absolute las cajas hijas siguen usando su contenedor de referencia
    width: 300px;
    height: 300px;
    /*background-color: lightskyblue;
    /*margin-left: 100px; /**El container se mueve con el elemento
}
.box-1{
    background-color: lightcoral;
    position: absolute; /**Box-2 que es static toma posicion porque box-1 perdio su espacio reservado
    /*left: 100px;
    bottom: 100px; /**Se mueve en relacion al html pq container no esa posicionado
    right: 0;
    bottom: 0; /**Usa como referencia el de la caja padre posicionada
}
.box-2{
    position: absolute; /**Pierde sus medidas por defecto /**STICKY CONTEXT
    background-color: lightgreen;
    /*right: 0;
    bottom: 0; /**Se coloca abajo del todo, pq toma como referencia el body, que es el padre
    /*bottom: 100px;
    left: 100px; /**Se coloca encima de box-1 porque se apilan
    right: 0;
    bottom: 0;/**Usa como referencia el del html
}
.link{
    position: absolute; /**Coge medidas como display block o display inline cuando tiene position absolute
    top: 50px;
    background-color: green;
    width: 200px;
}

    **<<<<<<<<<<POSITION FIXED>>>>>>>>>>>
body{
    background-color: #333;
    color: #fff;
    padding-top: 70px;
}
.header{
    text-align: center;
    padding: 25px 0;
    background-color: lightskyblue;
    color: orangered;
    position: fixed; /**Da igual si tiene un padre posicionada en relative absolute, siempre tomará el html como referencia
    top: 0;
    width: 100%; /**H1 se queda atras de .header
}
.link{
    position: fixed; /**Pierde su espacio reservado
    background-color: lightcoral;
    width: 200px;
}

    **<<<<<<<<<<POSITION STICKY>>>>>>>>>>>

body{
    background-color: #333;
    color: #ffffff;
}
img{
    display: block;
}
.header{
    /*position: sticky; /**Aqui lo recorremos desde el body
    text-align: center;
    background-color: lightskyblue;
    /*top: 0;
    height: 500px;
    overflow: hidden; /*! No funciona, cualquier otro valor de overflow
    /*! Sticky tampoco funciona si el alto del scroll no es suficiente
}
.menu{ /**Aqui estamos recorriendo el alto del elemento que contiene (menu recorre el alto de header)
    position: sticky;
    top: 0;
}
/**FIXED SE COLOCA REFERENTE AL HTML O BODY, PERO STICKY TOMA COMO REFERENCIA TOMA EL ALTO DEL PADRE EN BASE A SU CONTENIDO

/**Otro ejemplo de Sticky
.article-title{
    position: sticky;
    top: 0px;
    background-color: #333;
    outline: 2px solid red;
}
article{
    outline: 2px solid red;
}

*<<<<<<<<<<Z-INDEX>>>>>>>>>>>

body{
    background-color: #333;
    color: #fff;
}
.container{
    width: 200px;
    height: 200px;
    background-color: #555;
    position: relative;
}

.box{
    width: 100px;
    height: 100px;
    text-align: center;
    color: #333;
}
.box-1{
    background-color: lightcoral;
    position: relative;
    left: 150px;
    z-index: -1;
}
.box-1-2{
    background-color:lightskyblue;
    position: relative;
    z-index: -2;
    left: 200px;
    bottom: 100px;
}
.box-2{
    background-color: lightgreen;
    position: relative;
    top: 50px;
    z-index: 1; /**Modificamos su contexto de apilamiento
}
.box-3{/**Al tener los elementos posicionados el valor que vale es el de HTML
    background-color: lightseagreen;
    position: relative;
}
/**No utilizar numeros consecutivos con z-index, utilizar de 10 en 10 o de 100 en 100

*<<<<<<<<<<STACKING CONTEXT>>>>>>>>>>>
    El Stacking context o el contexto de apilamiento es el espacio donde nuestros elementos
    se van a ir apilando para que unos queden por detras y otros por delante

    El orden Stacking Context es: (de delante a atrás):
        ELementos posicionados con un z-index de 1 o mas
        Elementos posicionados sin z-index declarado (o z-index: auto)
        Elementos no posicionados
        Elementos con z-index negativo
*/
.box{
    width: 100px;
    height: 100px;
    text-align: center;
    color: #333;
}
.box-1{
    background-color: lightcoral;
    position: relative;
    z-index: 1; /**Se puede poner z index- cuando haya un elemento posicionado que se requiera poner sobre el*/
}
.box-2{ /*! Se puso delante del container, pero no de sus hijos text y title, es un elemento no posicionado dentro  de otro no posicionado*/
    background-color: lightgreen;
    margin-top: -50px;
    position: relative; /**Se da una posicion para arreglarlo*/
}
.box-3{
    background-color: lightseagreen;
}
.container{
    background-color: mediumslateblue;
    margin-top: -50px;
    position: relative;
    /*opacity: 0.75; /*!El container con opacity es un nuevo contexto menor que los elementos posicionados*/
}
.title{
    margin: 0;
    background-color: #ccc;
    position: relative; /**Se puso delante de text al posicionarse*/
    z-index: 10;
    opacity: 0.75; /**El opacity se resuelve dandoselo a los hijos del container*/
}
.text{
    margin: 0;
    margin-top: -40px;
}
