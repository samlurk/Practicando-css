/**<<<<<<SINTAXIS DE CSS>>>>>>

Selector: El elemento al que vamos aplicar estilos
Propiedad: Lo que vamos a cambiar
Valor: el nuevo valor que le vamos a dar la propiedad
Propiedad: valor -> Se le denomina declaracion
Al conjunto de selector+declaracion(es) se le denomina regla

Regla:
selector{ 
    propiedad:valor; declaracion
    propiedad2: valor; declaracion2
}


/**<<<<<<TIPOS DE SELECTORES>>>>>>*

~~~Selectores Simples
        Selectores elementales
            Selector Universal -> *
            Selector de tipo o etiquieta -> Nombre de la etiqueta
        Selectores de atributo
            id -> id del elemento
            clase -> clase del elemento
            otros atributos.
                [atributo]
                [atributo="valor"]
                [atributo^="valor"] Busca coincidencia al principio
                [atributo*="valor"] Busca coincidencia desde donde sea
                [atributo$="valor"] Seleccionar el valor si termina por esa palabra
                [atributo|="valor"] Incluye en y en-, ideal para lang
~~~Selectores Compuestos
        Selectores agrupados -> Se agrupan los selectores separados por comas y se escribeel estilo una sola vez
        Selectores Combinadores
            Selector descendiente -> Selector mayor Selector menor
            Selector de Hijos Selector -> Selector padre > Selector Hijos directos
            Selector de hermano(s) siguiente(s) 
                Selector para Hermanos siguientes -> Selector Hermano ~ Hermanos Siguientes (descendente html)
                Selector para Hermano siguiente en descendencia -> Hermano + hermano siguiente (descendente html)
        Pseudoclases - Pseudoelementos



/**<<UNIVERSAL>> Specify(0,0,0)

*{
    color: rgb(24, 89, 14); 
}

/**<<DE TIPO>> Specify(0,0,1)
h2{ 
    color: red;
}

/**<<DE CLASE>> Specify(0,1,0)
.title-h2{ 
    color:chocolate;
}
/**<<POR ATRIBUTO>> Specify(0,1,0)
[myAtributo]{
    color:darkred;
}

[myAtributo^="title"]{ Specify(0,1,0)
    color: red;
}

/**<<POR ID>> Specify(1,0,0)
#title-h2{
    color: blue;
}

/**<<POR DESCENDIENTE>>

div h2{ /*Specify(0,0,2)
    color: darkred;
}
.descendiente .title2-h2{ /*Specify(0,2,0)
    color: chocolate;
}
.descendiente [myAtributo2]{ /*Specify(0,2,0)
    color: red;
}
#title-h2 #title2-h2{ /*Specify(0,2,0)
    color:green;
}
/**PSEUDO-CLASES

.descendiente .title2-h2:hover{  /*Specify(0,3,0)
    color: red;
}

/**<<SELECTOR DE HIJOS>>
.descendiente > .title2-h2{ Specify(0,2,0)

}


/**<<<<<<ESPECIFIDAD>>>>>>

/**<<PSEUDO-ELEMENTOS>>

/**<<NIVEL DE JERARQUIA>>

!important 

Estilos en linea

Identificadores

Clases

Pseudo-clases

Atributos

Elementos

pseudo-elementos

    **El caculo de especifidad se realiza con la siguiente formula:
        Etiquetas y pseudo elementos 001
        Clases, atributos y pseudoclases 010
        Ids 100
        Estilos en linea 1000
        !important 10000
    Cascada -> Funciona siempre que la especifidad sobre el elemento sea la misma
    Herencia -> Capacidad que tienen algunos elementos de heredar algunas propiedades de sus elementos contenedores (padres, abuelos, etc)
*{
    color: blue !important;
}

h2{ /*Specify (0,0,1) important
    color: red !important;
}

#title2-h2{ /*Specify (1,0,0) important
    color:violet !important;
}

#title-h2 #title2-h2{ /*Specify (2,0,0) important
    color:green !important;
}

.title2-h2 + [myAtributo2="title-h2"] { /* Specify(0,2,0) Es el hermano siguiente en descendencia
    background-color: lightgreen;
}

.title2-h2 ~ [myAtributo2], .title2-h2 ~ #title2-h2{ /*Specify (0,2,0), Specify (1,1,0)
    background-color: lightskyblue;
}

body > .title-h2{ /*Specify (0,1,1)
    background-color:lightslategray;
}
/*<<A FONDO>>


h2 {
    color: blue;
}
h2.h2-title{ /*Specify (0,1,1)
    color: green;
}
.contenido h2.h2-title{ /*Specify (0,2,1)
    color: darkred;
}
h2#h2-title{/*Specify (1,0,1)
    color: brown;
}
h2.h2-title#h2-title{/*Specify (1,1,1)
    color: blueviolet;
}

div h2.h2-title#h2-title{ /*Specify 112 
    color: #000;
}
div.sub-contenido#sub-contenido h2{ /*Specify (1,1,1)
    color:chartreuse;
}
div.sub-contenido#sub-contenido  > h2.h2-title#h2-title:hover{ /*Specify (2,3,2)
    color:red;
}

h2.h2-title#h2-title + h2.h2-title#h2-title:hover{/*Specify ()
    color:blue;
}
div.sub-contenido#sub-contenido  h2.h2-title#h2-title:last-of-type:hover::first-letter{
    color:violet;
}

/*TENER UN CSS SIN PICOS, LO MAS LINEAL POSIBLE

/**<<<<<<HERENCIA>>>>>>*

~~~ Todos los temas entorno a fuentes y colores, se heredan.

~~~ Los enlaces no heredan propiedades de su padre.

.text{
    color: red;
}
a:link{
    
    text-decoration: none;
    color: inherit; /*La propiedad: inherit es para decir que queremos forzar la herencia, porque, en estos tipos de casos la propiedad no se hereda.
                    /*La propiedad initial es para decir que queremos que vuelvan a su estado inicial, todo aquello que estes heredando, ignoralo
}

li:not(.no-color){
    color: blue;
}

/**<<<<<<ESTILOS COMPUTADOS>>>>>>

/*body{
    color: rgba(255, 255, 255, 0.679);
    background-color: #333;
}

/*#title2-h2{
    color: red;
}
#title2-h2{
    color: lightskyblue;
}
/*user agent stylesheet | son estilos del navegador q trae por defecto

~~ Cuando se tenga un problema revisar el DevTools de Google, estilos y computados


/**<<<<<<BOX MODEL Y MARGIN >>>>>>
.title{
    width: 200px;
    margin-right: auto;
    margin-left: auto; /*! No se coloca a la derecha porque ocupa el ancho completo
    background-color: blue;
}
.block{
    background-color: purple;
    width: 200px;
    height: 200px;
    /*margin:  100px 50px 25px; 
    /*margin-left: auto;  /** Al darle el margen left y right calcula los 2 lados (centra la caja, no el texto)
    /*margin-right: auto;
}

/**Con bloques margin-right: auto; el elemento va a la izquierda e inverso a margin-left: auto;
 Para que esto funcione debe tener un ancho declarado y ser un elemento bloque


.inline{ /*Los elementos inline el tamaño no determina su contenido
    background-color: lightcoral;
    color: inherit;
    /*width: 200px; /*! no agarra
    /*height: 200px; /*! no agarra
    /*margin-top: 100px; /* !No agarra margen vertical
    /*margin-left: 200px; /*Agarra margen horizontal
}

/*
    Es la propiedad que nos permite generar espacio entre elementos 
    Es un shorthand que controla los 4 lados que dar margenes.
    margin-top 
    margin-right
    margin-bottom
    margin-left  

    Admite hasta 4 valores que van en el orden de las agujas del reloj
    4 valores -> margin: top right bottom left;
    3 valores -> margin: top left/right bottom;
    2 valores -> margin: top/bottom/ left/right;
    1 valor -> margin: top/right/bottom/left


/**<<<<<<<<<<METODOLOGIA BEM Y ORDEN DE ESTILOS EN CSS>>>>>>>>>>>>
.btn{
    width: 500px;
    margin: 30px auto 0px;
}

.btn__link{
    padding: 0.5em 1.1em;
    font-family: sans-serif;
    font-size: 0.95rem;
    text-decoration: none;
    color: white;
    background-color: #305BDF;
    border-radius: 1em;
}
.btn__link--primary:hover{
    background-color: #466DE2;
}
.btn__link--primary:active{
    background-color: #2251DD;
}
.btn__link--secondary{
    color: #4169E1;
    background-color: transparent;
    border: 2px solid #305BDF;
}
.btn__link--secondary:hover{
    color: #193CA3;
}
.btn__link--secondary:active{
    background-color: rgba(48,91,223, 0.15);
}
/*! ***********************MALAS PRACTICAS*****************************

/*! No utilizar margin 0 y padding 0 en caso de que se tenga un diseño y se requiera hacer todo

.block{
    margin-top:100px;
    /*margin: 0pxauto; /*!No utilizar esto para centrar
    margin-left: auto;
    margin-right: auto;
}

.header{
    background-color: red; /**Por defecto todos los navegadores ponen 8px de margin al body, resetearlas siempre (el normalize lo hace)
    height: 50px; /**No poner padding 0 en el body si no tiene, asegurarse de lo que se escribe tenga sentido, y escribirlo sabiendo por que lo estas escribiendo
    /**: No escribir codigo por que lo hemos visto en nosedonde
}

/**<<<<<<<<<<PADDING >>>>>>>>>>>>
/*Admite hasta los 4 valores que van en el orden de las agujas del reloj

.block{
    padding: 100px 10px 100px;
}
/**<<<<<<<<<<BORDER>>>>>>>>>>>>

/*Es un shorthand y agrupa 3 propiedades
    border-width
        border-top-width
        border-right-width
        border-bottom-width
        border-left-width
    border-style
        border-top-style
        border-right-style
        border-bottom-style
        border-left-style
            Listado de valores de style:
                none
                hidden
                dotted
                dashed
                doubled *divide espacios (divide el borde entre 2)*
                solid
                groove *hace sombra 3D*
                ridge *hace alreves lo que hace groove*
                inset (tenemos 2 bordes al diagonal de la caja)
                outset (invertir los 2 bordes de inset)
    border-color
        border-top-color
        border-right-color
        border-bottom-color
        border-left-color

.block{
    border: 20px solid slateblue;
    border-top-width: 10px;
    border-bottom-style:dotted;
    border-left-color: red;
}
/**<<<<<<<<<<BOX SIZING>>>>>>>>>>>>

/*Es la propiedad que nos permite controlar el calculo que hace el navegador a la hora de modificar las propiedades content, padding y border
    /*Los 2 valores que podemos darle son
        content-box -> Valor por defecto
        border-box -> Calculo de tamaño del elemento
        incluyento el padding y el border

.block{
    padding: 20px;
}

/**<<<<<<<<<<BORDER RADIUS CIRCULAR>>>>>>>>>>>>

Permite redondear vertices de forma independiente. Es un shorthand.

border-top-left-radius 
border-top-right-radius
border-top-bottom-right-radius
border-top-bottom-left-radius

.block{
    width: 200px;
    height: 200px;
    background-color: #ff0800;
    margin: 0px auto 0px;
    /*border-radius: 50px;
    /*ORDEN
    /*border-top-left-radius: 25px;
    border-top-right-radius: 50px;
    border-bottom-right-radius: 25px;
    border-bottom-left-radius: 75px;
    
    border-radius: esq. sup. izq. + esq. inf. der. | esq. sup. der. + esq. inf. izq. *2*
    border-radius:  esq. sup. izq. | esq. sup. der. (esq. inf. izq. toma el valor q tiene al frente )|  esq. inf. der. *3*
    border-radius:  esq. sup. izq. | esq. sup. der. |  esq. inf. der. | esq. inf. izq. *4*
    
}

/**<<<<<<<<<<BORDER RADIUS ELIPSES>>>>>>>>>>>

.block{
    border-top-left-radius: 50px 100px; /*ELIPSE EN UN SOLO LADO
    border-radius: 50px / 100px; /*50px en el eje X y 50 en el eje Y
}
.palo{
    width: 20px;
    height: 30px;
    margin: 300px auto 0px;
    background-color: #000;
    border-top-right-radius: 25px;
    border-bottom-left-radius: 30px;
}

/**<<<<<<<<<<OVERFLOW>>>>>>>>>>>

/*Es la propiedad de que controla que debe hacer la caja cuando su contenido se desborda del contenedor
    Es un shorthand que engloba overflow-x y overflow-y
    Tiene 4 posibles valores:
    visible -> Es el valor por defecto.
    hidden -> El contenido que se desborde no se verá. Si aplicamos esta propiedad en un solo eje, el otro se pondrá automáticamente en el valor scroll
    scroll -> Apareceran barras de scroll en el eje asignado (x, y o ambos)
    auto -> Apareceran barras de scroll en el caso de que hicieran falta 

/*.block{
    width: 300px;
    height: 300px;
    border-radius: 50px;
    margin: 0px auto 0px;
    background-color: #ff0800;

    overflow: hidden;
}
.text{
    /*width: 350px;
    margin: 0px;
}
.box-1, .box-2{
    padding: 30px 20px 10px;
    background-color: blue;
}

/**<<<<<<<<<<COLAPSADO DE MARGENES>>>>>>>>>>>
/*
LOS MARGENES VERTICALES COLAPSAN
Si la caja anterior tiene bottom de 20px y la siguiente tiene top de 30px, 20px se solapan y solamente se estiran 10px
Es decir...
LOS MARGENES SE SOLAPAN

SE SOLUCIONA DANDOLE MARGIN BOTTOM A TODOS LOS ELEMENTOS

body{
    background-color:midnightblue;
    
}
.header{
    background-color: lightcoral;
    height: 100px;
    margin-bottom: 20px;
    /**3 FORMAS DE SOLUCIONAR EL COLAPSADO DE IMAGENES ENTRE PADRES E HIJOS
    /*overflow: hidden;
    /*padding-top: 0.1px;
    border-top: 0.1px solid lightcoral;
}
.box-1,
.box-2{
    margin-left: auto;
    margin-right: auto;
    background-color: lightcyan;
    width: 300px;
    height: 300px;
}
/**No juntar margin bottom y margin tops porque daran muchos dolores de cabeza [Solo pasa en margenes verticales]
/*! Esto no lo hariamos 
.box-2{ 
    margin-top: 20px;
} 
.box-1{
    margin-bottom: 30px;
}
.title{
    margin: 0px; /*Se soluciona porque el h1 tiene margenes y los reseteamos
    margin-top: 30px;
}
h1{
    color:aliceblue;
}
/**<<<<<<<<<<DISPLAY>>>>>>>>>>>
Sirve para cambiar el contexto de los elementos dentro del navegador

Admite varios valores
    none -> Hace que el elemento no se muestre, pero sigue cargandose 
    block -> Hace que el elemento sea de bloque
    inline -> Hace que el elemento sea de linea
    inline-block -> Hace que el elemento sea de linea pero admite medidas y margenes verticales
    
body{
    background-color: rgba(0,0,0,.9);
}
.text{
    background-color: lightcoral;
}
.link{
    display:inline-block; /*El elemento crece pero sigue siendo de linea
    margin-top: 20px;
    background-color: #fff;
}

/**<<<<<<<<<<OUTLINE>>>>>>>>>>>
Es la propiedad que nos permite dibujar un borde por fuera del modelo de la caja.
Es un shorthand que engloba 
    outline-width
    outline-style
    outline-color

Tiene las mismas propiedades y sintaxis que border,
pero con algunas diferencias.
    No ocupa sitio, ya que no forma parte del box-model
    No se puede redondear 
    No se pueden controlar los lados de forma independiente

    Tambien cuenta con la propiedad outline-offset, que permite
    aumentar o disminuir la distancia del outline respecto a la caja que pertenece.
body{
    background-color: rgba(0,0,0,.9);
    color: white;
}

.border,
.outline{
    background-color: #666;
    width: 100px;
    padding: 10px 20px;
    margin: 50px 100px;
}
.border{
    border: 20px solid lightcoral;
}
.outline{
    outline: 3px solid lightcoral;
    /*border: 50px solid lightgreen;
    outline-offset: -13px; /**Podemos ponerlo dentro de la caja, cosa que con border no podemos hacer
    border: 3px solid lightgreen;
}
/*El borde tiene el problema que va estar modificando la caja, aumenta el tamanio de la caja y empuja los elementos
Aunque tengamos el box-sizing: border box
la caja no tiene medidas
Por lo tanto mide 50px de borde mas lo que tiene de contenido


/**<<<<<<<<<<TEXT ALIGN>>>>>>>>>>>
    Text-align es la propiedad que nos permite alinear horizontalmente el contenido de un elemento de bloque siempre que
    el contenido NO TENGA ANCHO DECLARADO
    text-align: left; -> Alinea Contenido a la der.
    text align: right; -> Alinea el contenido a la derecha
    text-align: center; -> Alinea el contenido al centro
    text-align: justify; -> Alinea el contenido de forma justificada. No es recomendable usarlo.

body{
    background-color: #333;
    color: white;
}
.box{
    background-color: #666;
    width: 100px;
    padding: 10px 0px;
    margin: 20px auto;
    border: 2px solid lightcoral;
    text-align: center; /**Si se puede porque el contenido no tiene ancho declarado
}
.text{
    text-align: left; /*El contenido suele estar alineado a la izquierda
    text-align: right;
    text-align: center;
    text-align: justify; /*No recomendable usar, quedan espacios feos entre palabras
}
.link{
    display: block; /*! No centra con inline e inline-block
    width: 200px; /**No centrara  con text align porque el contenido tiene un ancho declarado
    margin: 0px auto 20px;
    background-color: #666;
    color: white;
    text-align: center; /*! No se puede
    /*Text-align centra a los contenidos de los elementos de bloque
}
/*.img{
    display: block; /**EL contenido es la propia imagen y la imagen esta ocupado todo el tamaño de la caja 
    margin: 0px auto 0px;
    /*text-align: center; /*! No pasa nada
    /**Las imagenes por defecto son display inline block
}

/*Centrar la imagen desde un contenedor
.img-container{ /**La imagen centra, siempre y cuando no tenga un display block
    text-align: center;
}
/*.img{
    display: block; /*! No centra con img-container porque la imagen esta ocupando todo lo que puede*
}
/**TENER EN CUENTA SI LO QUE CENTRAMOS ES EL CONTENIDO DE UNA CAJA O LA CAJA EN SI


/**<<<<<<<<<<BOX SHADOW>>>>>>>>>>>
    La sintaxis de box-shadow se puede escribir de distintas formas segun lo que queramos conseguir.
    Los valores que le podemos poner son:
    offset-x -> Desplazamiento en x (obligatorio)
    offset-y -> Desplazamiento en y (obligatorio)
    blur-radius -> Desenfoque de la sombra
    spread-radius -> Expansion de la sombra
    color -> El color de la sombra, si no lo especificamos heredará del elemento al que pertenece
    inset -> Determina si la sombra será interior o exterior

.box{
    background-color: darkcyan;
    width: 200px;
    padding: 50px;
    text-align: center;
    margin: 50px auto 0px;
    border-radius: 30px;
    /*box-shadow: inset -5px -5px 10px 0px #111;
    /**El box shadow toma como herencia el color de la caja, si la letra esta en negra pues estara igual la sombra
    box-shadow: inset -5px -5px 10px red, 5px 5px 10px blue; /**Se pueden crear multiples sombras. Box shadow funciona como outline porque no mueve las cajas
}
/**<<<<<<<<<<POSITION>>>>>>>>>>>
    Position nos permite posicionar los elementos. Conceptos en tener en cuenta antes de entender position
    
    Flujo de renderizado -> Por norma general los elementos se dibujan de izquierda a derecha y de arriba abajo.
    El punto 0,0 de los elementos, por norma general, es la esquina superior izquierda.

    Espacio reservado -> Es el espacio que tiene un elemento asignado en el navegador.

    Elemento posicionado -> Esto significa que el elemento tiene la propiedad position con un valor de "static",
    que es el valor que tiene esta propiedad por defecto.

    Stackin context -> Contexto de apilamiento. Es el orden en el que se apilaran las cajas que se superponen,
    dentro del mismo contenedor.
    
    Al posicionar un elemento se habilitan 5 propiedades que podemos utilizar para mover
    los elementos en los 3 ejes.

    top -> El elemento se moverá desde la parte superior la distancia que le hayamos indicado.

    right -> El elemento se moverá desde la parte derecha la distancia que le hayamos indicado.

    bottom -> El elemento se moverá desde la parte inferior la distancia que le hayamos indicado

    left -> El elemento se mover[a desde la parte izquierda la distancia que le hayamos indicado.

    z-index -> Nos permite mover el elemento en el contexto de apilamiento (eje z)

    NOTA: Si a un elemento le declaramos la propiedad top y/o Left, las propiedades bottom y/o right no funcionarán

    Los posibles valores que le podemos dar a position son.
    Static -> Es el valor que tiene por defecto un elemento, con este valor el elemento 
    NO ESTÁ POSICIONADO y por lo cual no podemos moverlo 

    Elemento posicionados: 

    Relative -> El elemento mantendrá su posición y medidas en el flujo de renderizado y mantendrá su espacio reservado.
    Si lo movemos lo hará usando su posición en el html como punto de referencia.

    Absolute -> El elemento pederá sus medidas y su espacio reservado. Si lo movemos usará el elemento padre posicionado
    como referencia. Si no tiene ninguno, usará el elemento html de referencia.

    Fixed: -> El elemento perderá sus medidas y su espacio reservado.
    Si lo movemos usará el elemento html de referencia, y además se quedará fijo en esa posición aunque hagamos scroll.

    Sticky -> Es una mezcla de position relative y fixed.
    Con este tipo de posicionamiento los valores top, left, bottom y right no sirven para mover el elemento,
    si  no para indicarle en que punto pasará a tener un comportamiento de posicionamiento fixed, hasta llegar a ese punto
    se comportará como si tuviera relative.


    **<<<<<<<<<<POSITION RELATIVE>>>>>>>>>>>


body{
    background-color: #333;
}
.box {
    width: 100px;
    height: 100px;
}
.box-1{
    background-color: lightcoral;
    position: relative;
    top: 50px;
    left: 50px; /**Acepta valores negativos
    /*right: 25px; /*! No funciona porque ya tiene left
    /*bottom: 25px; /*! No funciona porque ya tiene top
    border-radius: 50px; /**El punto de referencia siempre es el mismo

} /**No se mueven al mismo sitio box-1 y box-2 porque se mueve desde la posicion inicial que les corresponde del html
.box-2{
    position: relative;
    right: 50px;    
    background-color: lightgreen;
} /**En posicion relative se le puede obligar a los elementos usar un mismo espacio

    **<<<<<<<<<<POSITION ABSOLUTE>>>>>>>>>>>

body{
    background-color: #333;
}
.box{
    width: 100px;
    height: 100px;

    text-align: center;
}
.container{
    position: relative; /**Si se cambia absolute las cajas hijas siguen usando su contenedor de referencia
    width: 300px;
    height: 300px;
    /*background-color: lightskyblue;
    /*margin-left: 100px; /**El container se mueve con el elemento
}
.box-1{
    background-color: lightcoral;
    position: absolute; /**Box-2 que es static toma posicion porque box-1 perdio su espacio reservado
    /*left: 100px;
    bottom: 100px; /**Se mueve en relacion al html pq container no esa posicionado
    right: 0;
    bottom: 0; /**Usa como referencia el de la caja padre posicionada
}
.box-2{
    position: absolute; /**Pierde sus medidas por defecto /**STICKY CONTEXT
    background-color: lightgreen;
    /*right: 0;
    bottom: 0; /**Se coloca abajo del todo, pq toma como referencia el body, que es el padre
    /*bottom: 100px;
    left: 100px; /**Se coloca encima de box-1 porque se apilan
    right: 0;
    bottom: 0;/**Usa como referencia el del html
}
.link{
    position: absolute; /**Coge medidas como display block o display inline cuando tiene position absolute
    top: 50px;
    background-color: green;
    width: 200px;
}

    **<<<<<<<<<<POSITION FIXED>>>>>>>>>>>
body{
    background-color: #333;
    color: #fff;
    padding-top: 70px;
}
.header{
    text-align: center;
    padding: 25px 0;
    background-color: lightskyblue;
    color: orangered;
    position: fixed; /**Da igual si tiene un padre posicionada en relative absolute, siempre tomará el html como referencia
    top: 0;
    width: 100%; /**H1 se queda atras de .header
}
.link{
    position: fixed; /**Pierde su espacio reservado
    background-color: lightcoral;
    width: 200px;
}

    **<<<<<<<<<<POSITION STICKY>>>>>>>>>>>

body{
    background-color: #333;
    color: #ffffff;
}
img{
    display: block;
}
.header{
    /*position: sticky; /**Aqui lo recorremos desde el body
    text-align: center;
    background-color: lightskyblue;
    /*top: 0;
    height: 500px;
    overflow: hidden; /*! No funciona, cualquier otro valor de overflow
    /*! Sticky tampoco funciona si el alto del scroll no es suficiente
}
.menu{ /**Aqui estamos recorriendo el alto del elemento que contiene (menu recorre el alto de header)
    position: sticky;
    top: 0;
}
/**FIXED SE COLOCA REFERENTE AL HTML O BODY, PERO STICKY TOMA COMO REFERENCIA TOMA EL ALTO DEL PADRE EN BASE A SU CONTENIDO

/**Otro ejemplo de Sticky
.article-title{
    position: sticky;
    top: 0px;
    background-color: #333;
    outline: 2px solid red;
}
article{
    outline: 2px solid red;
}

*<<<<<<<<<<Z-INDEX>>>>>>>>>>>

body{
    background-color: #333;
    color: #fff;
}
.container{
    width: 200px;
    height: 200px;
    background-color: #555;
    position: relative;
}

.box{
    width: 100px;
    height: 100px;
    text-align: center;
    color: #333;
}
.box-1{
    background-color: lightcoral;
    position: relative;
    left: 150px;
    z-index: -1;
}
.box-1-2{
    background-color:lightskyblue;
    position: relative;
    z-index: -2;
    left: 200px;
    bottom: 100px;
}
.box-2{
    background-color: lightgreen;
    position: relative;
    top: 50px;
    z-index: 1; /**Modificamos su contexto de apilamiento
}
.box-3{/**Al tener los elementos posicionados el valor que vale es el de HTML
    background-color: lightseagreen;
    position: relative;
}
/**No utilizar numeros consecutivos con z-index, utilizar de 10 en 10 o de 100 en 100

*<<<<<<<<<<STACKING CONTEXT>>>>>>>>>>>
    El Stacking context o el contexto de apilamiento es el espacio donde nuestros elementos
    se van a ir apilando para que unos queden por detras y otros por delante

    El orden Stacking Context es: (de delante a atrás):
        ELementos posicionados con un z-index de 1 o mas
        Elementos posicionados sin z-index declarado (o z-index: auto)
        Elementos no posicionados
        Elementos con z-index negativo

.box{
    width: 100px;
    height: 100px;
    text-align: center;
    color: #333;
}
.box-1{
    background-color: lightcoral;
    position: relative;
    z-index: 1; /**Se puede poner z index- cuando haya un elemento posicionado que se requiera poner sobre el
}
.box-2{ /*! Se puso delante del container, pero no de sus hijos text y title, es un elemento no posicionado dentro  de otro no posicionado
    background-color: lightgreen;
    margin-top: -50px;
    position: relative; /**Se da una posicion para arreglarlo
}
.box-3{
    background-color: lightseagreen;
}
.container{
    background-color: mediumslateblue;
    margin-top: -50px;
    position: relative;
    /*opacity: 0.75; /*!El container con opacity es un nuevo contexto menor que los elementos posicionados
}
.title{
    margin: 0;
    background-color: #ccc;
    position: relative; /**Se puso delante de text al posicionarse
    z-index: 10;
    opacity: 0.75; /**El opacity se resuelve dandoselo a los hijos del container
}
.text{
    margin: 0;
    margin-top: -40px;
}

*<<<<<<<<<<ORDEN DE PROPIEDADES>>>>>>>>>>>
1- Propiedades de posicionamiento
2- Propiedades del box model
3- Propiedades de texto
4- Propiedades visuales (colores, bordes, background...)
5- El resto
body{
    position: relative;
    top: 50px;
    left: 20px;
    overflow: hidden;
    font-size: 30px;
    background: red;
    color: blue;
    border: 30px solid lightskyblue;
    animaciones, etc etc
}

*<<<<<<<<<<MEDIDAS ABSOLUTAS Y RELATIVAS>>>>>>>>>>>
Las medidas en CSS se pueden agrupar en 2 grupos, absolutas y relativas

    Las absolutas NO CAMBIAN y siempre mantendrán su tamaño independientemente
    del dispositivo o la interacción del usuario.
    La más usada es px (pixeles) cuya medida es 1/96 de 1in, pero existen otras comoÑ
    cm (centimetros) -> 1cm = 96px/2,54
    mm (milimetros) -> 1mm = 1/10 de 1cm
    Q (cuarto de milimetro) 1Q = 1/40 de 1cm
    in (inches, pulgadas) -> 1in = 2,54cm = 96px
    pc (picas) -> = 1/76 de 1in
    pt (puntos) -> 1pt = 1/72 de 1in

    Las medidas relativas SIEMPRE dependen de un contexto son las que se recomienda
    utilizar en la gran mayoría de ocasiones porque nos van a permitir que todos los elementos
    escalen proporcionalmente.
    Las más usadas son em, rem, %, vw, vh, vmin y vmax aunque tenemos otras comoÑ
    ex -> Altura x de la fuente del elemento.
    ch -> La medida del ancho del glifo "0" de la letra del elemento.
    lh -> Altura de la linea del elemento

    *<<<<<<<<<<MEDIDAS EM Y REM>>>>>>>>>>>

    rem -> Corresponde a la medida "m" de la raiz del documento (html)
    
    ejemplo: 16px (tamaño raiz) = 1rem 

    em -> Corresponde a la medida "m" del contexto donde nos encontremos

    El estandar del tamaño de fuente por defecto en la raiz del documento es de 16px,
    y NO ES RECOMENDABLE MODIFICARLO

    /**En imprenta la m es el caracter mas grande

    /**Es de 16px por defecto en la raiz del documento porque equivale a los 12px que se usan en imprenta 
    NOTA: Tanto "em" como "rem" se calcula en base a la propiedad font-size (tamaño de la fuente)


body{
    background-color: #333;
    color: lightcoral;
    /*font-size: 10px; /**em toma las medidas mediante el contexto en donde te encuentras a diferencia de rem que usa la raiz del documento que son 16px
}

.title{
    font-size: 2rem; /**a pesar de que cambio el contexto, no cambia la medida porque usa la raiz del documento
    /**Usar siempre rem para tamaños de fuente
}

/**Casos en los que se usa em en vez de rem

.link{
    background-color: lightcoral;
    color: #333;
    /*padding: 1rem 2rem; /*! No sigue siendo coherente el padding y el radius con el rem
    border-radius: .5rem;
    padding: 1em 2em; /**Em si es coherente con el mismo espacio a pesar de que siga creciendo, porque usa el contexto del tamaño del texto para medir su tamaño
    border-radius: .5em;
    font-size: 1rem; /*A medida que vaya creciendo no tiene el mismo padding porque la medida es absoluta (si se usa padding rem)
}

    *<<<<<<<<<<Width en % y Width Auto>>>>>>>>>>>
    
    % -> Cuando usamos porcentage usamos de referencia el tamaño del contenedor y el navegador calcula ese porcentage. Esto no ocurre cuando usamos transform.

    auto -> Cuando usamos auto le pedimos al navegador que calcule en funcion del espacio disponible.

body{
    background-color: #333;
    color: lightcoral;
}
.box{
    width: 100%;
    height: 250px;
    background-color: lightgreen;
    margin: 0 50px; /**Si no se deja auto en width, se genera un scroll, si la medida de la caja mas el margen tiene mas ancho que el dispositivo se genera un scroll
    width: auto;
}
.box-hijo{
    width: 100%; /**Crece proporcionalmente
    height: 25%;
    margin-left: 50px; /**Pero se rompe si usamos margin
    /**Se resuelve si usamos
    width: auto; /**El navegador calcula el ancho, en base al ancho que tiene disponible en el padre
    background-color: lightseagreen;
}

    *<<<<<<<<<<Height en % y Height Auto>>>>>>>>>>>


    % -> Cuando estamos dentro de un contenedor, 
    este tiene que tener un alto declarado, si no 
    no podrá calcular el porcentaje. Si se le aplica una medida
    con porcentale se sustituirá  automaticamente por auto.

    auto -> Cuando utilizamos auto el alto lo calculará el navegador en base al contenido del elemento

    NOTA: Height es una propiedad que se tiene que usar con mucho cuidado. Si no es necesario
    establecer el alto, dejar que el contenido sea el que decida el alto del elemento.
    
body{
    background-color: #333;
    color: lightcoral;
    /*height: 500px; Es poco comun darle al body un height
}
.header{
    background-color: lightskyblue;
    text-align: center;
}
.box{
    width: 300px;
    height: 300px; /*La caja desaparece
    /*height: 100%; /*! El Height se pone en base al contenido, porque no tiene contenedor, es el body, pero el body no tiene alto declarado
    /**Lo que esta haciendo el height 100% es calcular la altura de forma automatica, porque el contenedor no tiene alto declarado
    /*padding-bottom: 1em;
    /**Si se quiere ganar espacio usar padding en vez de height
    **dado que usando height y se agg mas cosas el contenido se desborda, si se hace con padding, siempre tendra el mismo espacio 
    background-color: lightgreen;
}
.box-hijo{
    position: absolute;
    width: 50%;
    height: 50%; /**Si no tiene ancho declarado el contenedor se le sustituira por auto y esto genera problemas
    background-color: lightseagreen;
}
/**Cuando usamos auto el calculo lo va hacer el navegador en base al contenido del elemento

Si el hijo no tiene nada y el padre no tiene alto declarado, al poner auto, no se va a mostrar nada, pq no tiene contenido, aunque le hayamos declarado alto al hijo

    **~~~~~~~~~~Problemas de Height con Posicionamiento~~~~~~~~~~~~~*


body{
    background-color: #333;
    color: lightcoral;
}
.header{
    background-color: lightskyblue;
    text-align: center;
}
.box{
    width: 300px;
    height: 300px; 
    background-color: lightgreen;
}
.box-hijo{
    top: 0;
    position: absolute; /*! Se rompe, con fixed pasa lo mismo, y no se guia del padre al darle height. Se calcula en base al viewport 
    /**Con position Relative y Sticky vuelven a la normalidad
    width: 50%;
    height: 100%; 
    background-color: lightseagreen;
}
/**El Viewport equivale al todo el espacio visible que tenemos


    *<<<<<<<<<<Medidas Relativas al Viewport Responsive>>>>>>>>>>>

    El viewport es el área útil donde se mostrará la página web.
    IMPORTANTE, tener en cuenta que es el área visible sin hacer scroll.
    Podemos usar el viewport como medida de varias formas:
    vw -> Viewport Width, hace referencia ancho del viewport.
    vh -> Viewport Height, hace referencia al alto del viewport.
    vmax -> Utiliza el valor más grande entre el ancho y el alto del viewport.
    vmin -> Utiliza el valor más pequeño entre el ancho y el alto del viewport

    1vw = 1% del ancho del viewport.
    1vh = 1% del alto del viewport.
    1vmin = 1% del valor que sea más pequeño del viewport
    1vmax = 1% del valor que sea más grande del viewport
    

html{
    height: 300px;
}
body{
    background-color: #333;
    color: lightcoral;
}
.header{
    background-color: lightskyblue;
    text-align: center;
    /*height: 100vh; /**Ocupa 100px del area visible sin hacer scroll
    /*width: 100vw; /*! Aparece una barra de scroll horizontal en desktop.
    /*! No usar 100vw, 
    /**Usar width: 100% si lo necesita
}
.box{
    width: 300px;
    height: 300px; 
    width: 50vw;
    background-color: lightgreen;
}
.box-hijo{
    position: absolute;
    /*width: 100vw;
    top: 0;
    width: 50%; /**Cambia con respecto al contenedor
    /*width: 50vw; /**Cambia con respecto al viewport
    /*width: 100vmin; /**El ancho va a tener un minimo de 100% viewport mientras que viewport width sea mas pequeño que viewport height
    /*width:  50vmax; /**El ancho va a tener un maximo de 50% de viewport mientras que el viewport width sea mas grande que viewport height
    /*height: 150px; 
    width: 50vmin;
    height: 50vmax;
    background-color: lightseagreen;
}
/**No es un valor que se escriba en muchos sitios ni que se escriba a la ligera,
/**Pero segun se vayan haciendo practicas, se va a ver q vmin y vmax nos ayuda ajustar la fuentes en base al tamaño del dispositivo que son mas faciles de calcular que hacer una media query o calcularlo por porcentajes, etc

/**<<<<<<<<<<Limitadores de ancho y alto>>>>>>>>>>>
Cuando establecemos un width y/o un height con una medida que es relativa,
es posible que no queramos que se respete esa medida en todos los casos.
Para ello tenemos propiedades que limitan esas medidas:
    min-width: Indica el ancho minimo que puede alcanzar el elemento 
    max-width: Indica el ancho máximo que puede alcanzar el elemento
    min-height: Indica el alto minimo que puede alcanzar el elemento
    max-height: Indica el alto máximo que puede alcanazar el elemento

    

    html{
        height: 300px;
    }
    body{
        background-color: #333;
        color: lightcoral;
    }
    .header{
        background-color: lightskyblue;
        text-align: center;
    }
    .box{
        /**min-width y max-width es util para hacer responsive
        max-width: 600px; /**Crece hasta 600px
        min-width: 500px; /**Decrece hasta 500px y aparece la barra de scroll
        height: 60vw; /**El alto va a tener 60% del ancho
        background-color: lightgreen;
        /**Estos 2 no se usan casi
        max-height: 300px;
        min-height: 100px;
    }

    body{
        position: relative; /**Debemos posicionar los elementos del body para que tome el absolute de los elementos hijo
        background-color: #333;
        color: lightcoral;
        min-height: 100vh; /**Para que el body utilice el alto del viewport, y llegue a la parte inferior como minimo
        border: 4px solid red;
    }
    p{
        margin: 0;
    }
    .footer{
        position:absolute;
        bottom: 0; /**! No funciona cuando hacemos scroll con el position absolute y bottom 0
        width: 100%;
        padding: 1rem 0;
        color: white;
        text-align: center;
        background-color: lightseagreen;
    }
/**No es porque dorian lo ponga yo lo ponga siempre

/**Esto es un truco para que se quiera tener un elemento en la parte inferior de la pagina y el contenido no rellene todo, se pueda utilizar


/**<<<<<<<<<<Codigos de Colores en CSS>>>>>>>>>>>
    Colores
    La mayoría de las pantallas funcionan con un modo de color aditivo.
    La suma de RGB da como resultado un blanco
    Tenemos varias formas de dar color en CSS
    
    IMPORTANTE: Recordar que existe el color transparent

*/
body{
    background-color: #333;
    color: lightcoral;
}
.contenedor{
    width: 300px;
    height: 300px;
}
.box{
    border-top: 200px solid lightseagreen; /**Se pone top para que sea el que se muestre la punta*/
    border-right: 250px solid transparent; 
    border-left: 250px solid transparent;
    transform: rotate(0.5turn); /**Rota el eje de el triangulo*/
    /*width: 300px;
    height: 300px;
    background-color: transparent;*/
}